<!DOCTYPE html>
  <meta charset="utf-8"/>
  <head>
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" href="../fonts.css">
    <script src="../pdfjs/build/pdf.js"></script>
  </head>
  <body>
    <div class="header">
      <span class="listing no-border" id="header-trademark-and-title">
        <img id="header-trademark" src="../trademark.jpg" onclick="location.href='../index.html'">
        <span id="header-title" onclick="location.href='./prefix-free_codes.pdf#page=2'"> Prefix-Free Codes </span>
      </span>
    </div>
    <div class="subheader">
      <div disabled class="need label"> Links: </div>
      <div class="need" tabindex="0" onclick="location.href='./prefix-free_codes.pdf#page=2'" onkeypress="location.href='./prefix-free_codes.pdf#page=2'">
        <span> Sheet PDF </span>
        <span class="caret">›</span>
      </div>
      <div class="need" tabindex="0" onclick="location.href='./prefix-free_codes-graph.pdf'" onkeypress="location.href='./prefix-free_codes-graph.pdf'">
        <span> Graph PDF </span>
        <span class="caret">›</span>
      </div>
      
        <div disabled class="need label"> Needs: </div>
        
            <div class="need" tabindex="0" onclick="location.href='./codes.html'" onkeypress="location.href='./codes.html'">
              <span>
                Codes
              </span>
              <span class="caret">›</span>
            </div>
        
      
      
        <div disabled class="need label"> Needed by: </div>
        
          <div class="need" tabindex="0" onclick="location.href='./optimal_average_codeword_length.html'" onkeypress="location.href='./optimal_average_codeword_length.html'">
            <span>
            Optimal Average Codeword Length
            </span>
            <span class="caret">›</span>
          </div>
        
          <div class="need" tabindex="0" onclick="location.href='./prefix_trees.html'" onkeypress="location.href='./prefix_trees.html'">
            <span>
            Prefix Trees
            </span>
            <span class="caret">›</span>
          </div>
        
      
    </div>

      <link rel="stylesheet" href="../katex/katex.min.css">
      <script src="../katex/katex.min.js"></script>
      <script src="../katex/auto-render.min.js"></script>
      <script>
      document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(
          document.body,
          {
            delimiters: [
              {left: "$$", right: "$$", display: true},
              {left: "$", right: "$", display: false},
            ],
          },
        );
      });
    </script>
    <div id="sheet-card" class="card">
      <div class="sheet-listing" id="why"><h1 class="sheet">1. Why</h1></div><div class="sheet-listing"><p class="sheet"> Let $X$ and $A$ be finite sets. Here are two practical considerations for constructing a code $C: X \to \strings(A)$.</p></div><div class="sheet-listing"><p class="sheet"> First, the code should be nonsingular (injective). In other words, no two objects in the base set have the same codewords.</p></div><div class="sheet-listing"><p class="sheet"> Second, no additional information should be required to indicate where codewords start and end. This second restriction indicates that no codeword should appear as the first part of another codeword of greater length. This second implication motivates this sheet.</p></div><div class="sheet-listing" id="definition"><h1 class="sheet">2. Definition</h1></div><div class="sheet-listing"><p class="sheet"> We call a string $s \in \strings(A)$ of length $m$ a \t{prefix} of a string $t \in \strings(A)$ of length $n$ if $m \leq n$ and $s_i = t_i$ for all $i \in \upto{m}$.</p></div><div class="sheet-listing"><p class="sheet"> We call a code $c: X \to \strings(A)$ \t{prefix-free} if, for all $x \in X$, $c(x)$ is <i>not</i> a prefix of $c(x')$ for all $x' \neq x$, $x' \in X$. Otherwise, we call the code \t{prefixed}. All prefix-free codes are uniquely decodable, but the converse is false.</p></div><div class="sheet-listing"><p class="sheet"> \begin{proposition} There exists a set $X$, alphabet $A$, and prefixed code $C: X \to \CA$ such that $C$ is uniquely decodable. \begin{proof} Let $\alpha$ and $\beta$ be objects. Try $X = \set{\alpha, \beta}$, $A = \set{0, 1}$ and $c: X \to \strings(A)$ defined by $c(\alpha) = (0,)$ , $c(\beta) = (0,1)$. We proceed by induction on the length of encodings. Consider a length one encoding. It must be $(0,)$, which decodes as $(A,)$. Consider a length two encoding. It is either $(0,0)$, which decodes as $(A,A)$, or it is $(0,1)$ which decodes as $(B,)$. Now assume the cases $k-1$ and $k-2$. Now consider a length $k$ code $a \in \strings(A)$. It consists of $(a_{1:k-1},a_k)$. If $a_k = 0$, then the the code must be $(y, \alpha)$ where $y$ is the decoding of $a_{1:k-1}$. By the induction hypothesis, $a_{1:k-1}$ is of length $k-1$ and so uniquely decodable. Otherwise, $(a_{k-1}, a_k) = (0,1)$ and so the code must be $(y', \beta)$ where $y'$ is the decoding of $a_{a:k-2}$. By the induction hypothesis, $a_{1:k-2}$ is of length $k-2$ and so uniquely decodable. \end{proof} \end{proposition}</p></div><div class="sheet-listing"><p class="sheet"> In other words, the prefix-free codes are a <i>strict</i> subset of the uniquely decodable codes. However, our second consideration mentioned above indicates that the "practical" codes are prefix-free.</p></div>
    </div>

    <div style="display: flex; flex-direction: row; justify-content: center; flex-wrap: wrap">

    <div id="wrapper1">
      <canvas id="page1" style="direction: ltr;"></canvas>
    </div>
    <div id="wrapper2">
      <canvas id="page2" style="direction: ltr;"></canvas>
    </div>
    <div id="wrapper3">
    <canvas id="page3" style="direction: ltr;" onclick="location.href='./prefix-free_codes-graph.pdf'"></canvas>
    </div>
      <script id="script">
        // If absolute URL from the remote server is provided, configure the CORS
        // header on that server.
        var url = './prefix-free_codes.pdf';

        // The workerSrc property shall be specified.
        pdfjsLib.GlobalWorkerOptions.workerSrc =
          '../pdfjs/build/pdf.worker.js';

        var PRINT_RESOLUTION = 300;

        function render(page, wrapper, canvas) {
          var scale = 7;
          var viewport = page.getViewport({scale: scale});
          var context = canvas.getContext('2d');

          canvas.width = viewport.width;
          canvas.height = viewport.height;
          canvas.style.width = "100%";
          canvas.style.height = "100%";
          wrapper.style.width = Math.floor(viewport.width/scale) + 'pt';
          wrapper.style.height = Math.floor(viewport.height/scale) + 'pt';

          // see https://stackoverflow.com/questions/37861686/pdfjs-blurry-pdf-on-ipad
          // who knows if this works...
          context.imageSmoothingEnabled = false;
          context.webkitImageSmoothingEnabled = false;
          context.mozImageSmoothingEnabled = false;
          context.oImageSmoothingEnabled = false;

          /*

          if (window.devicePixelRatio > 1) {
            var canvasWidth = canvas.width;
            var canvasHeight = canvas.height;

            canvas.width = canvasWidth * window.devicePixelRatio;
            canvas.height = canvasHeight * window.devicePixelRatio;
            canvas.style.width = canvasWidth + "px";
            canvas.style.height = canvasHeight + "px";

            context.scale(window.devicePixelRatio, window.devicePixelRatio);
          }
          //end see
          */

          var renderContext = {
            canvasContext: context,
            viewport: viewport
          };
          page.render(renderContext);
        }

        // Asynchronous download PDF
        var loadingTask = pdfjsLib.getDocument(url);
        loadingTask.promise.then(function(pdf) {

          // Fetch the first page
          pdf.getPage(2).then(function(page) {
              render(page, document.getElementById('wrapper1'), document.getElementById('page1'));
          });

          // Fetch the second page
          pdf.getPage(3).then(function(page) {
            render(page, document.getElementById('wrapper2'), document.getElementById('page2'));
          });

          // Fetch the third page
          pdf.getPage(4).then(function(page) {
            render(page, document.getElementById('wrapper3'), document.getElementById('page3'));
          });
        });
      </script>

    <!-- PAGES -->
    <!--
    <iframe id="sheet-pdf" src="./prefix-free_codes.pdf#page=2">
    </iframe>
    <iframe id="sheet-pdf" src="./prefix-free_codes.pdf#page=3">
    </iframe>
    -->
    <!-- PAGES -->

    </div>

    <!-- <iframe id="graph-pdf" src="./prefix-free_codes-graph.pdf">
    </iframe>
    -->

    <span id="footer">
      Copyright 2022 The Bourbaki Authors. Version a34ea766f.
    </span>
  </body>
</html>
