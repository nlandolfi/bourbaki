%!name:codes
%!need:sequences
%!refs:david_huffman/a_method_for_the_construction_of_minimum_redundancy_codes

\ssection{Why}\footnote{Future editions will include, with perhaps discussion of encoding and representing text.}

\ssection{Definition}

Let $X$ be a set and let $A$ be a finite set.
We denote the set of all finite sequences (strings) in $A$ by $\strings(A)$.
We read $\strings(A)$ aloud as \say{the strings in $A$.}
The length zero string is $\emptyset$.

A \t{code} for $X$ \t{in} $A$ is a function from $X$ to $\strings(A)$.
In this context, we refer to the finite set $A$ as an \t{alphabet} and we call $c(x)$ the \t{codeword} of $x$.
The \t{length} of $x \in X$, with respect to a code $c: X \to \strings(A)$, is the length of the sequence $c(x)$ (its codeword).
We call a code \t{nonsingular} if it is injective.

\ssubsection{Examples}

Define $c: \set{\alpha, \beta} \to \set{0, 1}$ by $c(\alpha) = (0,)$ and $c(\beta) = (1,)$.\footnote{Future editions will include additional examples.}

\ssection{Code extensions}


Let $s,t \in \strings(A)$ of length $m$  and $n$ respectively.
The \t{concatenation} of $s$ with $t$ is the length $m+n$ string $u \in \strings(A)$ defined by $u_{1} = s_1, \dots, u_m = s_m$ and $u_{m+1} = t_1, \dots, u_{m+n} = t_n$.
We denote the concatenation of $s$ and $t$ by $st$.
Note, however, that $st \neq ts$, although $s(tr) = (st)r$.

Given a code $c: X \to \strings(A)$, we can produce a code for $\strings(X)$ in a natural way.
The \t{extension} of $c$ is the function $C: \strings(X) \to \strings(A)$ defined, for $\xi = (\xi_1, \dots, \xi_n) \in \strings(X)$, by
\[
  C(\xi) = c(\xi_1) \cdots c(\xi_n).
\]
We call an code \t{uniquely decodable} if its extension is injective.
In other words, given the code $C(\xi)$ for a sequence $\xi \in \strings(X)$, we can recover $\xi$.
We call $C(\xi)$ the \t{encoding} of $\xi$.
We call $\xi$ the \t{decoding} of $C(\xi)$.

