%!name:codes
%!need:sequences

\ssection{Why}\footnote{Future editions will include, with perhaps discussion of encoding a representing text.}

\ssection{Definition}

Let $X$ be a set and let $A$ be a finite set.
We denote the set of all finite sequences (strings) in $A$ by $\strings(A)$.
We read $\strings(A)$ aloud as \say{the strings in $A$.}

A \t{code} for $X$ \t{in} $A$ is a function from $X$ to $\strings(A)$.
In this context, we refer to the finite set $A$ as an \t{alphabet}.
The \t{length} of $x \in X$, with respect to a code $c: X \to \strings(A)$, is the length of the sequence $c(x)$.
We call a code \t{nonsingular} if it is injective.

\ssection{Examples}

Define $c: \set{\alpha, \beta} \to \set{0, 1}$ by $c(\alpha) = (0,)$ and $c(\beta) = (1,)$.

\ssection{Code extensions}


Let $s,t \in \strings(A)$ of length $m$  and $n$ respectively.
The \t{concatenation} of $s$ with $t$ is the length $m+n$ string $u \in \strings(A)$ defined by $u_{1} = s_1, \dots, u_m = s_m$ and $u_{m+1} = t_1, \dots, u_{m+n} = t_n$.
We denote the concatenation of $s$ and $t$ by $st$.
Note, however, that $st \neq ts$, although $s(tr) = (st)r$.

Given a code $c: X \to \strings(A)$, we can produce a code for $\strings(X)$ in a natural way.
The \t{extension} of $c$ is the function $C: \strings(X) \to \strings(A)$ defined, for $\xi = (\xi_1, \dots, \xi_n) \in \strings(X)$, by
\[
  C(\xi) = c(\xi_1) \cdots c(\xi_n).
\]
We call an code \t{uniquely decodable} if its extension is injective.
In other words, given the code $C(\xi)$ for a sequence $\xi \in \strings(X)$, we can recover $\xi$.
We call $C(\xi)$ the \t{encoding} of $\xi$.
We call $\xi$ the \t{decoding} of $C(\xi)$.

\ssection{Prefix-free codes}

We call a string $s \in \strings(A)$ of length $m$ a \t{prefix} of a string $t \in \strings(A)$ of length $n$ if $m \leq n$ and $s_i = t_i$ for all $i \in \upto{m}$.

We call a code $c: X \to \strings(A)$ \t{prefix-free} if, for all $x \in X$, $c(x)$ is \textit{not} a prefix of $c(x')$ for all $x' \neq x$, $x' \in X$.
Otherwise, we call the code \t{prefixed}.
All prefix-free codes are uniquely decodable, but the converse is false.

\begin{proposition}
  There exists a set $X$, alphabet $A$, and prefixed code $C: X \to \CA$ such that $C$ is uniquely decodable.
  \begin{proof}
  Let $\alpha$ and $\beta$ be objects.
    Try $X = \set{\alpha, \beta}$, $A = \set{0, 1}$ and $c: X \to \strings(A)$ defined by $c(\alpha) = (0,)$ , $c(\beta) = (0,1)$.
  We proceed by induction on the length of encodings.
  Consider a length one encoding.
  It must be $(0,)$, which decodes as $(A,)$.
  Consider a length two encoding.
  It is either $(0,0)$, which decodes as $(A,A)$, or it is $(0,1)$ which decodes as $(B,)$.
  Now assume the cases $k-1$ and $k-2$.
  Now consider a length $k$ code $a \in \strings(A)$.
  It consists of $(a_{1:k-1},a_k)$.
  If $a_k = 0$, then the the code must be $(y, \alpha)$ where $y$ is the decoding of $a_{1:k-1}$.
  By the induction hypothesis, $a_{1:k-1}$ is of length $k-1$ and so uniquely decodable.
  Otherwise, $(a_{k-1}, a_k) = (0,1)$ and so the code must be $(y', \beta)$ where $y'$ is the decoding of $a_{a:k-2}$.
  By the induction hypothesis, $a_{1:k-2}$ is of length $k-2$ and so uniquely decodable.
  \end{proof}
\end{proposition}

In other words, the prefix-free codes are a \textit{strict} subset of the uniquely decodable codes.
